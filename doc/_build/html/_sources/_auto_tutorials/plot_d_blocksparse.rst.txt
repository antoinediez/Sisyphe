
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_auto_tutorials/plot_d_blocksparse.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download__auto_tutorials_plot_d_blocksparse.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__auto_tutorials_plot_d_blocksparse.py:


.. _tutobsr:

Tutorial 04: Block-sparse reduction 
============================================

In many cases, the interaction radius :math:`R` is much smaller than the size of the domain. Consequently, the sums in the local averages (see :ref:`tuto_averages`) contain only a small fraction of non zero terms. To gain in efficiency, we can follow the classical strategy:

* Subdivide the domain into a fixed number of cells of size at least :math:`R`.
* For a particle in a given cell, only look at the contiguous cells to compute the local averages. In dimension :math:`d`, there are :math:`3^d` contiguous cells (including the cell itself). 

A practical implementation is called the *Verlet list method*. However, the implementation below is different than the classical one. It is adapted from the `block-sparse reduction method <https://www.kernel-operations.io/keops/_auto_examples/pytorch/plot_grid_cluster_pytorch.html>`_ implemented in the `KeOps <https://www.kernel-operations.io/keops/index.html>`_ library. 

We illustrate the gain in efficency for the Vicsek model. 

.. note::
    The method is sub-optimal for moderate numbers of particles. As a rule of thumb, the block-sparse reduction method becomes useful for systems with at least :math:`10^4` particles. 

.. GENERATED FROM PYTHON SOURCE LINES 22-27

Set up and benchmarks
---------------------------

First, some standard imports...


.. GENERATED FROM PYTHON SOURCE LINES 27-36

.. code-block:: default


    import copy
    import time 
    import torch
    from matplotlib import pyplot as plt

    use_cuda = torch.cuda.is_available()
    dtype = torch.cuda.FloatTensor if use_cuda else torch.FloatTensor








.. GENERATED FROM PYTHON SOURCE LINES 37-39

Let the :math:`N` particles be uniformly scattered in a box of size :math:`L` with interaction radius  :math:`R` and uniformly sampled velocities. 


.. GENERATED FROM PYTHON SOURCE LINES 39-58

.. code-block:: default


    from sisyphe.models import Vicsek

    N = 100000
    L = 100.  
    R = 1.

    pos = L*torch.rand((N,2)).type(dtype)
    vel = torch.randn(N,2).type(dtype)
    vel = vel/torch.norm(vel,dim=1).reshape((N,1))

    simu=Vicsek(pos=pos,vel=vel,
                v=1.,
                sigma=1.,nu=3.,
                interaction_radius=R,
                box_size=L)

    simu.__next__() #GPU warmup... 





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    {'position': tensor([[31.6564,  6.3145],
            [61.3271, 90.9929],
            [88.1392,  1.8941],
            ...,
            [98.8685, 90.9011],
            [28.4884, 29.0810],
            [15.1606, 66.4232]], device='cuda:0'), 'velocity': tensor([[ 0.9581, -0.2866],
            [-0.2292, -0.9734],
            [-0.8279, -0.5608],
            ...,
            [-0.6027, -0.7979],
            [ 0.9594, -0.2821],
            [-0.4047, -0.9145]], device='cuda:0')}



.. GENERATED FROM PYTHON SOURCE LINES 59-60

Without block-sparse reduction, let us compute the simulation time of 100 iterations.

.. GENERATED FROM PYTHON SOURCE LINES 60-71

.. code-block:: default


    simu_copy = copy.deepcopy(simu) # Make a new deepcopy
    s = time.time()
    for k in range(100):
        simu_copy.__next__()
    e = time.time()

    simulation_time = e-s

    print("Average simulation time without block-sparse reduction: " + str(simulation_time) + " seconds.")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Average simulation time without block-sparse reduction: 2.9741082191467285 seconds.




.. GENERATED FROM PYTHON SOURCE LINES 72-73

Then with block-sparse reduction... First, turn on the attribute :attr:`blocksparse <sispyphe.particles.Particles.blocksparse>`. 

.. GENERATED FROM PYTHON SOURCE LINES 73-76

.. code-block:: default

      
    simu.blocksparse = True
      







.. GENERATED FROM PYTHON SOURCE LINES 77-79

Then, we need to define the maximum number of cells. This can be set by the keyword argument ``number_of_cells`` when an instance of the class :class:`sisyphe.particles.Particles` is created. The number of cells has a strong influence on the efficiency of the method and should be chosen wisely.  When the optimal value is not known a priori, it is recommanded to use the  method :meth:`best_blocksparse_parameters() <sisyphe.particles.Particles.best_blocksparse_parameters>` which will time 100 iterations of the simulation for various numbers of cells and automatically choose the best one. Below, we test all the numbers of cells which are powers of the dimension (here :math:`d=2`) between :math:`10^2` and :math:`70^2`. 


.. GENERATED FROM PYTHON SOURCE LINES 79-85

.. code-block:: default

 
    ncell_min = 10
    ncell_max = 70
    fastest, nb_cells, average_simu_time, simulation_time = simu.best_blocksparse_parameters(ncell_min, ncell_max, step=1, nb_calls=100)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Progress:0.0%    Progress:1.67%    Progress:3.33%    Progress:5.0%    Progress:6.67%    Progress:8.33%    Progress:10.0%    Progress:11.67%    Progress:13.33%    Progress:15.0%    Progress:16.67%    Progress:18.33%    Progress:20.0%    Progress:21.67%    Progress:23.33%    Progress:25.0%    Progress:26.67%    Progress:28.33%    Progress:30.0%    Progress:31.67%    Progress:33.33%    Progress:35.0%    Progress:36.67%    Progress:38.33%    Progress:40.0%    Progress:41.67%    Progress:43.33%    Progress:45.0%    Progress:46.67%    Progress:48.33%    Progress:50.0%    Progress:51.67%    Progress:53.33%    Progress:55.0%    Progress:56.67%    Progress:58.33%    Progress:60.0%    Progress:61.67%    Progress:63.33%    Progress:65.0%    Progress:66.67%    Progress:68.33%    Progress:70.0%    Progress:71.67%    Progress:73.33%    Progress:75.0%    Progress:76.67%    Progress:78.33%    Progress:80.0%    Progress:81.67%    Progress:83.33%    Progress:85.0%    Progress:86.67%    Progress:88.33%    Progress:90.0%    Progress:91.67%    Progress:93.33%    Progress:95.0%    Progress:96.67%    Progress:98.33%



.. GENERATED FROM PYTHON SOURCE LINES 86-87

We plot the average simulation time as a function of the square root of the number of cells and print the best. 

.. GENERATED FROM PYTHON SOURCE LINES 87-94

.. code-block:: default


    plt.plot(nb_cells,average_simu_time)      
    plt.xlabel("Square root of the number of cells") 
    plt.ylabel("Simulation time") 

    print("Average simulation time with block-sparse reduction: " + str(average_simu_time.min()) + " seconds.")




.. image:: /_auto_tutorials/images/sphx_glr_plot_d_blocksparse_001.png
    :alt: plot d blocksparse
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Average simulation time with block-sparse reduction: 0.4012424945831299 seconds.




.. GENERATED FROM PYTHON SOURCE LINES 95-96

Same experiment with one million particles. 

.. GENERATED FROM PYTHON SOURCE LINES 96-123

.. code-block:: default


    N = 1000000
    L = 100.  
    R = 1.

    pos = L*torch.rand((N,2)).type(dtype)
    vel = torch.randn(N,2).type(dtype)
    vel = vel/torch.norm(vel,dim=1).reshape((N,1))


    simu=Vicsek(pos=pos,vel=vel,
                v=1.,
                sigma=1.,nu=3.,
                interaction_radius=R,
                box_size=L,
                block_sparse_reduction=False)

    simu_copy = copy.deepcopy(simu) # Make a new deepcopy
    s = time.time()
    for k in range(100):
        simu_copy.__next__()
    e = time.time()

    simulation_time = e-s

    print("Average simulation time without block-sparse reduction: " + str(simulation_time) + " seconds.")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Average simulation time without block-sparse reduction: 274.7271876335144 seconds.




.. GENERATED FROM PYTHON SOURCE LINES 124-125

With block-sparse reduction...

.. GENERATED FROM PYTHON SOURCE LINES 125-131

.. code-block:: default


    simu.blocksparse = True

    fastest, nb_cells, average_simu_time, simulation_time = simu.best_blocksparse_parameters(30, 100, nb_calls=100)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Progress:0.0%    Progress:1.43%    Progress:2.86%    Progress:4.29%    Progress:5.71%    Progress:7.14%    Progress:8.57%    Progress:10.0%    Progress:11.43%    Progress:12.86%    Progress:14.29%    Progress:15.71%    Progress:17.14%    Progress:18.57%    Progress:20.0%    Progress:21.43%    Progress:22.86%    Progress:24.29%    Progress:25.71%    Progress:27.14%    Progress:28.57%    Progress:30.0%    Progress:31.43%    Progress:32.86%    Progress:34.29%    Progress:35.71%    Progress:37.14%    Progress:38.57%    Progress:40.0%    Progress:41.43%    Progress:42.86%    Progress:44.29%    Progress:45.71%    Progress:47.14%    Progress:48.57%    Progress:50.0%    Progress:51.43%    Progress:52.86%    Progress:54.29%    Progress:55.71%    Progress:57.14%    Progress:58.57%    Progress:60.0%    Progress:61.43%    Progress:62.86%    Progress:64.29%    Progress:65.71%    Progress:67.14%    Progress:68.57%    Progress:70.0%    Progress:71.43%    Progress:72.86%    Progress:74.29%    Progress:75.71%    Progress:77.14%    Progress:78.57%    Progress:80.0%    Progress:81.43%    Progress:82.86%    Progress:84.29%    Progress:85.71%    Progress:87.14%    Progress:88.57%    Progress:90.0%    Progress:91.43%    Progress:92.86%    Progress:94.29%    Progress:95.71%    Progress:97.14%    Progress:98.57%



.. GENERATED FROM PYTHON SOURCE LINES 132-133

We plot the average simulation time as a function of the square root of the number of cells and print the best. 

.. GENERATED FROM PYTHON SOURCE LINES 133-140

.. code-block:: default


    plt.plot(nb_cells,average_simu_time)      
    plt.xlabel("Square root of the number of cells") 
    plt.ylabel("Simulation time") 

    print("Average simulation time with block-sparse reduction: " + str(average_simu_time.min()) + " seconds.")




.. image:: /_auto_tutorials/images/sphx_glr_plot_d_blocksparse_002.png
    :alt: plot d blocksparse
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Average simulation time with block-sparse reduction: 2.2031195163726807 seconds.




.. GENERATED FROM PYTHON SOURCE LINES 141-143

.. note::
        The optimal parameters chosen initially may not stay optimal in the course of the simulation. This may be the case in particular if there is a strong concentration of particles.

.. GENERATED FROM PYTHON SOURCE LINES 145-178

How does it work 
---------------------------------

Cell size and number of cells
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The cells have a rectangular shape. The length of the cells along each dimension cannot be smaller than the interaction radius :math:`R`. The maximum number of cells is thus equal to: 

.. math::

        n_\mathrm{max} = \prod_{k=1}^d \left\lfloor \frac{L_k}{R} \right\rfloor,

where :math:`L_k` is the length of the (rectangular) domain along dimension :math:`k`. This corresponds to rectangular cells with a length along dimension :math:`k` equal to: 

.. math:: 

        \varepsilon_k = \frac{L_k}{\left\lfloor \frac{L_k}{R} \right\rfloor}.

If the number of cells demanded :math:`n_0` exceeds :math:`n_\mathrm{max}`, this will be the chosen value. Otherwise, we first compute the typical length: 

.. math:: 

        \varepsilon_0 = \left(\frac{\prod_{k=1}^d L_k}{n_0}\right)^{1/d}

Then the length of the cells along dimension :math:`k` is set to

.. math::

        \varepsilon_k = \frac{L_k}{\left\lfloor\frac{L_k}{\varepsilon_0}\right\rfloor}.

In particular, in a square domain :math:`L_k=L` for all :math:`k` and when :math:`n_0` is a power of :math:`d`, then there are exactly :math:`n_0` square cells with length :math:`L/n_0^{1/d}`. 



.. GENERATED FROM PYTHON SOURCE LINES 180-193

The block-sparse parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The initialisation or the method :meth:`best_blocksparse_parameters() <sisyphe.particles.Particles.best_blocksparse_parameters>` define three attributes which are used to speed up the computations. Given a number of cells, they are computed by the method :meth:`compute_blocksparse_parameters() <sisyphe.particles.Particles.compute_blocksparse_parameters>`.

* :attr:`centroids <sisyphe.Particles.particles.centroids>` : the coordinates of the centers of the cells. 
* :attr:`keep <sisyphe.Particles.particles.keep>` : a square BoolTensor which indicates whether two cells are contiguous. 
* :attr:`eps <sisyphe.Particles.particles.keep>` : the length of the cells along each dimension. 

The particles are clustered into the cells using the method :meth:`uniform_grid_separation() <sisyphe.toolbox.uniform_grid_separation>`. 

.. note::
    A drawback of the method is the high memory cost needed to store the boolean mask :attr:`keep <sisyphe.Particles.particles.keep>`. As a consequence, unlike the classical Verlet list method, the optimal number of cells is often **not** the maximum one. In the examples presented in this documentation, the optimal number of cells is always smaller than :math:`10^4`. 


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 8 minutes  9.001 seconds)


.. _sphx_glr_download__auto_tutorials_plot_d_blocksparse.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_d_blocksparse.py <plot_d_blocksparse.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_d_blocksparse.ipynb <plot_d_blocksparse.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
